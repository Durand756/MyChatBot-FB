const express = require('express');
const mysql = require('mysql2/promise');
const axios = require('axios');
const path = require('path');
const session = require('express-session');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration Facebook App - √Ä MODIFIER avec vos vraies valeurs
const FACEBOOK_CONFIG = {
    app_id: process.env.FACEBOOK_APP_ID || 'YOUR_FACEBOOK_APP_ID',
    app_secret: process.env.FACEBOOK_APP_SECRET || 'YOUR_FACEBOOK_APP_SECRET',
    redirect_uri: process.env.REDIRECT_URI || `http://localhost:${PORT}/auth/facebook/callback`
};

// Configuration de la base de donn√©es
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'facebook_automation',
    port: process.env.DB_PORT || 3306,
    connectionLimit: 10
};

// Configuration session s√©curis√©e
const sessionConfig = {
    secret: process.env.SESSION_SECRET || crypto.randomBytes(64).toString('hex'),
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000 // 24 heures
    }
};

// Middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));
app.use(session(sessionConfig));

// Pool de connexions √† la base de donn√©es
let dbPool;

/**
 * Initialise la connexion √† la base de donn√©es MySQL
 */
async function initDB() {
    try {
        console.log('üîÑ Connexion √† la base de donn√©es...');
        dbPool = mysql.createPool(dbConfig);
        
        // Test de la connexion
        const connection = await dbPool.getConnection();
        console.log('‚úÖ Connect√© √† MySQL');
        connection.release();
        
        await createTables();
    } catch (error) {
        console.error('‚ùå Erreur connexion DB:', error.message);
        
        // Fallback mode d√©mo si pas de DB
        console.log('‚ö†Ô∏è Mode d√©mo activ√© (sans base de donn√©es)');
        dbPool = null;
    }
}

/**
 * Cr√©e les tables n√©cessaires dans la base de donn√©es
 */
async function createTables() {
    if (!dbPool) return;
    
    try {
        // Table des utilisateurs Facebook
        await dbPool.execute(`
            CREATE TABLE IF NOT EXISTS facebook_users (
                id INT AUTO_INCREMENT PRIMARY KEY,
                facebook_id VARCHAR(255) UNIQUE NOT NULL,
                name VARCHAR(255) NOT NULL,
                email VARCHAR(255),
                profile_picture TEXT,
                access_token TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            )
        `);

        // Table des pages Facebook connect√©es
        await dbPool.execute(`
            CREATE TABLE IF NOT EXISTS connected_pages (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id INT NOT NULL,
                page_id VARCHAR(255) NOT NULL,
                page_name VARCHAR(255) NOT NULL,
                page_access_token TEXT NOT NULL,
                is_active BOOLEAN DEFAULT false,
                webhook_verified BOOLEAN DEFAULT false,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES facebook_users(id) ON DELETE CASCADE,
                UNIQUE KEY unique_user_page (user_id, page_id)
            )
        `);

        // Table des r√©ponses automatiques
        await dbPool.execute(`
            CREATE TABLE IF NOT EXISTS auto_responses (
                id INT AUTO_INCREMENT PRIMARY KEY,
                page_id VARCHAR(255) NOT NULL,
                keyword VARCHAR(255) NOT NULL,
                response TEXT NOT NULL,
                priority INT DEFAULT 1,
                is_active BOOLEAN DEFAULT true,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_page_keyword (page_id, keyword)
            )
        `);

        // Table des conversations
        await dbPool.execute(`
            CREATE TABLE IF NOT EXISTS conversations (
                id INT AUTO_INCREMENT PRIMARY KEY,
                page_id VARCHAR(255) NOT NULL,
                sender_id VARCHAR(255) NOT NULL,
                message_text TEXT NOT NULL,
                response_text TEXT,
                response_type ENUM('keyword', 'ai', 'none') DEFAULT 'none',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_page_sender (page_id, sender_id),
                INDEX idx_created_at (created_at)
            )
        `);

        console.log('‚úÖ Tables cr√©√©es/v√©rifi√©es');
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation tables:', error.message);
    }
}

/**
 * Ex√©cute une requ√™te SQL de mani√®re s√©curis√©e
 */
async function executeQuery(query, params = []) {
    if (!dbPool) {
        console.log('‚ö†Ô∏è Mode d√©mo - requ√™te simul√©e');
        return [[], { insertId: 1, affectedRows: 1 }];
    }
    
    try {
        const [rows] = await dbPool.execute(query, params);
        return [rows, { insertId: rows.insertId, affectedRows: rows.affectedRows }];
    } catch (error) {
        console.error('‚ùå Erreur SQL:', error.message);
        throw error;
    }
}

/**
 * Middleware pour v√©rifier l'authentification utilisateur
 */
function requireAuth(req, res, next) {
    if (!req.session.user) {
        return res.status(401).json({ error: 'Non authentifi√©' });
    }
    next();
}

// ===== ROUTES D'AUTHENTIFICATION FACEBOOK =====

/**
 * G√©n√®re l'URL de connexion Facebook avec les permissions n√©cessaires
 */
app.get('/auth/facebook', (req, res) => {
    const state = crypto.randomBytes(32).toString('hex');
    req.session.oauth_state = state;
    
    const scopes = [
        'email',
        'pages_show_list',
        'pages_manage_metadata',
        'pages_messaging',
        'pages_read_engagement'
    ].join(',');
    
    const facebookAuthUrl = `https://www.facebook.com/v18.0/dialog/oauth?` +
        `client_id=${FACEBOOK_CONFIG.app_id}&` +
        `redirect_uri=${encodeURIComponent(FACEBOOK_CONFIG.redirect_uri)}&` +
        `scope=${encodeURIComponent(scopes)}&` +
        `response_type=code&` +
        `state=${state}`;
    
    res.redirect(facebookAuthUrl);
});

/**
 * Callback apr√®s authentification Facebook
 */
app.get('/auth/facebook/callback', async (req, res) => {
    const { code, state } = req.query;
    
    // V√©rification du state pour √©viter les attaques CSRF
    if (state !== req.session.oauth_state) {
        return res.redirect('/?error=invalid_state');
    }
    
    if (!code) {
        return res.redirect('/?error=access_denied');
    }
    
    try {
        // √âchanger le code contre un access token
        const tokenResponse = await axios.get('https://graph.facebook.com/v18.0/oauth/access_token', {
            params: {
                client_id: FACEBOOK_CONFIG.app_id,
                client_secret: FACEBOOK_CONFIG.app_secret,
                redirect_uri: FACEBOOK_CONFIG.redirect_uri,
                code: code
            }
        });
        
        const { access_token } = tokenResponse.data;
        
        // R√©cup√©rer les informations de l'utilisateur
        const userResponse = await axios.get('https://graph.facebook.com/v18.0/me', {
            params: {
                fields: 'id,name,email,picture',
                access_token: access_token
            }
        });
        
        const userData = userResponse.data;
        
        // Sauvegarder ou mettre √† jour l'utilisateur dans la DB
        await saveOrUpdateUser(userData, access_token);
        
        // Cr√©er la session utilisateur
        req.session.user = {
            facebook_id: userData.id,
            name: userData.name,
            email: userData.email,
            profile_picture: userData.picture?.data?.url,
            access_token: access_token
        };
        
        console.log(`‚úÖ Utilisateur connect√©: ${userData.name}`);
        res.redirect('/?login=success');
        
    } catch (error) {
        console.error('‚ùå Erreur callback Facebook:', error.message);
        res.redirect('/?error=auth_failed');
    }
});

/**
 * Sauvegarde ou met √† jour un utilisateur Facebook
 */
async function saveOrUpdateUser(userData, accessToken) {
    try {
        const [existingUsers] = await executeQuery(
            'SELECT id FROM facebook_users WHERE facebook_id = ?',
            [userData.id]
        );
        
        if (existingUsers.length > 0) {
            // Mise √† jour de l'utilisateur existant
            await executeQuery(
                'UPDATE facebook_users SET name = ?, email = ?, profile_picture = ?, access_token = ?, updated_at = NOW() WHERE facebook_id = ?',
                [userData.name, userData.email, userData.picture?.data?.url, accessToken, userData.id]
            );
        } else {
            // Cr√©ation d'un nouvel utilisateur
            await executeQuery(
                'INSERT INTO facebook_users (facebook_id, name, email, profile_picture, access_token) VALUES (?, ?, ?, ?, ?)',
                [userData.id, userData.name, userData.email, userData.picture?.data?.url, accessToken]
            );
        }
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde utilisateur:', error.message);
    }
}

// ===== ROUTES API =====

/**
 * R√©cup√®re les informations de l'utilisateur connect√©
 */
app.get('/api/user', requireAuth, (req, res) => {
    res.json({
        success: true,
        user: {
            name: req.session.user.name,
            email: req.session.user.email,
            profile_picture: req.session.user.profile_picture
        }
    });
});

/**
 * R√©cup√®re la liste des pages Facebook de l'utilisateur
 */
app.get('/api/pages', requireAuth, async (req, res) => {
    try {
        const response = await axios.get('https://graph.facebook.com/v18.0/me/accounts', {
            params: {
                access_token: req.session.user.access_token,
                fields: 'id,name,category,tasks,access_token'
            }
        });
        
        const pages = response.data.data.filter(page => 
            page.tasks && page.tasks.includes('MANAGE')
        );
        
        // R√©cup√©rer le statut de connexion pour chaque page
        const [connectedPages] = await executeQuery(
            'SELECT page_id, is_active FROM connected_pages WHERE user_id = (SELECT id FROM facebook_users WHERE facebook_id = ?)',
            [req.session.user.facebook_id]
        );
        
        const connectedPageMap = {};
        connectedPages.forEach(page => {
            connectedPageMap[page.page_id] = page.is_active;
        });
        
        const pagesWithStatus = pages.map(page => ({
            id: page.id,
            name: page.name,
            category: page.category,
            access_token: page.access_token,
            is_connected: connectedPageMap[page.id] || false
        }));
        
        res.json({
            success: true,
            pages: pagesWithStatus
        });
        
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration pages:', error.message);
        res.status(500).json({ 
            success: false, 
            error: 'Impossible de r√©cup√©rer les pages' 
        });
    }
});

/**
 * Connecte une page Facebook pour l'automatisation
 */
app.post('/api/pages/connect', requireAuth, async (req, res) => {
    const { pageId, pageName, pageAccessToken } = req.body;
    
    try {
        // R√©cup√©rer l'ID utilisateur depuis la DB
        const [users] = await executeQuery(
            'SELECT id FROM facebook_users WHERE facebook_id = ?',
            [req.session.user.facebook_id]
        );
        
        if (users.length === 0) {
            return res.status(404).json({ 
                success: false, 
                error: 'Utilisateur non trouv√©' 
            });
        }
        
        const userId = users[0].id;
        
        // Sauvegarder la page connect√©e
        await executeQuery(
            `INSERT INTO connected_pages (user_id, page_id, page_name, page_access_token, is_active) 
             VALUES (?, ?, ?, ?, true) 
             ON DUPLICATE KEY UPDATE 
             page_name = VALUES(page_name), 
             page_access_token = VALUES(page_access_token), 
             is_active = true`,
            [userId, pageId, pageName, pageAccessToken]
        );
        
        console.log(`‚úÖ Page connect√©e: ${pageName} (${pageId})`);
        
        res.json({
            success: true,
            message: 'Page connect√©e avec succ√®s'
        });
        
    } catch (error) {
        console.error('‚ùå Erreur connexion page:', error.message);
        res.status(500).json({
            success: false,
            error: 'Erreur lors de la connexion de la page'
        });
    }
});

/**
 * D√©connecte une page Facebook
 */
app.post('/api/pages/disconnect', requireAuth, async (req, res) => {
    const { pageId } = req.body;
    
    try {
        await executeQuery(
            `UPDATE connected_pages 
             SET is_active = false 
             WHERE page_id = ? AND user_id = (
                 SELECT id FROM facebook_users WHERE facebook_id = ?
             )`,
            [pageId, req.session.user.facebook_id]
        );
        
        console.log(`üîå Page d√©connect√©e: ${pageId}`);
        
        res.json({
            success: true,
            message: 'Page d√©connect√©e avec succ√®s'
        });
        
    } catch (error) {
        console.error('‚ùå Erreur d√©connexion page:', error.message);
        res.status(500).json({
            success: false,
            error: 'Erreur lors de la d√©connexion'
        });
    }
});

/**
 * Ajoute une r√©ponse automatique pour une page
 */
app.post('/api/responses', requireAuth, async (req, res) => {
    const { pageId, keyword, response, priority = 1 } = req.body;
    
    try {
        await executeQuery(
            'INSERT INTO auto_responses (page_id, keyword, response, priority) VALUES (?, ?, ?, ?)',
            [pageId, keyword, response, priority]
        );
        
        res.json({
            success: true,
            message: 'R√©ponse automatique ajout√©e'
        });
        
    } catch (error) {
        console.error('‚ùå Erreur ajout r√©ponse:', error.message);
        res.status(500).json({
            success: false,
            error: 'Erreur lors de l\'ajout de la r√©ponse'
        });
    }
});

/**
 * R√©cup√®re les r√©ponses automatiques d'une page
 */
app.get('/api/responses/:pageId', requireAuth, async (req, res) => {
    try {
        const [responses] = await executeQuery(
            'SELECT * FROM auto_responses WHERE page_id = ? ORDER BY priority DESC, created_at DESC',
            [req.params.pageId]
        );
        
        res.json({
            success: true,
            responses: responses
        });
        
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration r√©ponses:', error.message);
        res.status(500).json({
            success: false,
            error: 'Erreur lors de la r√©cup√©ration'
        });
    }
});

/**
 * D√©connexion de l'utilisateur
 */
app.post('/api/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            console.error('‚ùå Erreur d√©connexion:', err);
            return res.status(500).json({ 
                success: false, 
                error: 'Erreur lors de la d√©connexion' 
            });
        }
        
        res.json({
            success: true,
            message: 'D√©connect√© avec succ√®s'
        });
    });
});

// ===== WEBHOOK FACEBOOK MESSENGER =====

/**
 * V√©rification du webhook Facebook
 */
app.get('/webhook', (req, res) => {
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];
    
    // Token de v√©rification (√† d√©finir dans votre app Facebook)
    const VERIFY_TOKEN = process.env.WEBHOOK_VERIFY_TOKEN || 'your_webhook_verify_token';
    
    if (mode && token) {
        if (mode === 'subscribe' && token === VERIFY_TOKEN) {
            console.log('‚úÖ Webhook v√©rifi√©');
            res.status(200).send(challenge);
        } else {
            res.sendStatus(403);
        }
    } else {
        res.sendStatus(400);
    }
});

/**
 * R√©ception des messages via webhook
 */
app.post('/webhook', async (req, res) => {
    const body = req.body;
    
    if (body.object === 'page') {
        body.entry.forEach(async (entry) => {
            const pageId = entry.id;
            
            if (entry.messaging) {
                entry.messaging.forEach(async (event) => {
                    if (event.message && event.message.text) {
                        await handleIncomingMessage(pageId, event);
                    }
                });
            }
        });
    }
    
    res.status(200).send('EVENT_RECEIVED');
});

/**
 * Traite un message entrant et g√©n√®re une r√©ponse automatique
 */
async function handleIncomingMessage(pageId, event) {
    try {
        const senderId = event.sender.id;
        const messageText = event.message.text;
        
        console.log(`üì® Message re√ßu sur page ${pageId}: "${messageText}"`);
        
        // R√©cup√©rer le token de la page
        const [pages] = await executeQuery(
            'SELECT page_access_token FROM connected_pages WHERE page_id = ? AND is_active = true',
            [pageId]
        );
        
        if (pages.length === 0) {
            console.log(`‚ö†Ô∏è Page ${pageId} non trouv√©e ou inactive`);
            return;
        }
        
        const pageAccessToken = pages[0].page_access_token;
        
        // Chercher une r√©ponse automatique correspondante
        const [responses] = await executeQuery(
            'SELECT response FROM auto_responses WHERE page_id = ? AND is_active = true AND LOWER(?) LIKE LOWER(CONCAT("%", keyword, "%")) ORDER BY priority DESC LIMIT 1',
            [pageId, messageText]
        );
        
        let responseText = null;
        let responseType = 'none';
        
        if (responses.length > 0) {
            responseText = responses[0].response;
            responseType = 'keyword';
            
            // Envoyer la r√©ponse
            await sendMessage(pageAccessToken, senderId, responseText);
            console.log(`üì§ R√©ponse automatique envoy√©e: "${responseText}"`);
        }
        
        // Sauvegarder la conversation
        await executeQuery(
            'INSERT INTO conversations (page_id, sender_id, message_text, response_text, response_type) VALUES (?, ?, ?, ?, ?)',
            [pageId, senderId, messageText, responseText, responseType]
        );
        
    } catch (error) {
        console.error('‚ùå Erreur traitement message:', error.message);
    }
}

/**
 * Envoie un message via l'API Facebook Messenger
 */
async function sendMessage(pageAccessToken, recipientId, messageText) {
    try {
        await axios.post(`https://graph.facebook.com/v18.0/me/messages?access_token=${pageAccessToken}`, {
            recipient: { id: recipientId },
            message: { text: messageText }
        });
        return true;
    } catch (error) {
        console.error('‚ùå Erreur envoi message:', error.response?.data || error.message);
        return false;
    }
}

// ===== ROUTES G√âN√âRALES =====

/**
 * API de sant√© pour v√©rifier le statut du serveur
 */
app.get('/api/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        database: dbPool ? 'connected' : 'demo_mode',
        session: req.session.user ? 'authenticated' : 'anonymous'
    });
});

/**
 * Servir le fichier HTML principal
 */
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

/**
 * Redirection pour toutes les autres routes vers l'index
 */
app.get('*', (req, res) => {
    res.redirect('/');
});

// ===== GESTION DES ERREURS =====

/**
 * Middleware de gestion globale des erreurs
 */
app.use((error, req, res, next) => {
    console.error('‚ùå Erreur serveur:', error);
    res.status(500).json({
        success: false,
        error: 'Erreur interne du serveur'
    });
});

/**
 * Fermeture propre du serveur
 */
process.on('SIGINT', async () => {
    console.log('üîÑ Arr√™t du serveur...');
    if (dbPool) {
        await dbPool.end();
        console.log('‚úÖ Connexion DB ferm√©e');
    }
    process.exit(0);
});

// ===== D√âMARRAGE DU SERVEUR =====

async function startServer() {
    // Chargement des variables d'environnement
    try {
        require('dotenv').config();
    } catch (e) {
        console.log('‚ö†Ô∏è dotenv non trouv√©, utilisation des valeurs par d√©faut');
    }
    
    // V√©rification de la configuration Facebook
    if (FACEBOOK_CONFIG.app_id === 'YOUR_FACEBOOK_APP_ID') {
        console.log('‚ö†Ô∏è ATTENTION: Configurez vos identifiants Facebook dans les variables d\'environnement');
        console.log('   FACEBOOK_APP_ID et FACEBOOK_APP_SECRET requis');
    }
    
    await initDB();
    
    app.listen(PORT, () => {
        console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
        console.log(`üåê URL: http://localhost:${PORT}`);
        console.log(`üì± Facebook App ID: ${FACEBOOK_CONFIG.app_id}`);
        console.log(`üíæ Base de donn√©es: ${dbPool ? '‚úÖ Connect√©e' : '‚ö†Ô∏è Mode d√©mo'}`);
        console.log(`üîó Redirect URI: ${FACEBOOK_CONFIG.redirect_uri}`);
    });
}

startServer().catch(error => {
    console.error('‚ùå Erreur critique au d√©marrage:', error);
    process.exit(1);
});
